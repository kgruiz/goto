#!/usr/bin/env bash
set -euo pipefail

if ! command -v cargo >/dev/null 2>&1; then
  echo "error: cargo is required but was not found in PATH." >&2
  echo "Install Rust via https://rustup.rs/ and ensure cargo is available." >&2
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

BIN_NAME="to"
PROJECT_NAME="to"
CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"
TARGET_PATH="${CARGO_HOME}/bin/${BIN_NAME}"
CONFIG_BASE="${XDG_CONFIG_HOME:-$HOME/.config}"
WRAPPER_PATH="${CONFIG_BASE}/zsh/plugins/goto/goto.zsh"
COMPLETION_DIR="${CONFIG_BASE}/zsh/completions"
COMPLETION_FILE="${COMPLETION_DIR}/_to"

usage() {
  cat <<'EOUSAGE'
Usage: ./install [FLAGS] [cargo install flags]

Flags:
  -y, --yes, --force     bypass conflict prompts and proceed
  -q, --quiet            suppress prompts (implies --yes)
  -h, --help             display this help message

All other arguments are forwarded to "cargo install".
EOUSAGE
}

FORCE=false
NON_INTERACTIVE=false
CARGO_ARGS=()

while (($#)); do
  case "$1" in
    -q|--quiet)
      NON_INTERACTIVE=true
      FORCE=true
      ;;
    -y|--yes|--force)
      FORCE=true
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      CARGO_ARGS+=("$1")
      ;;
  esac
  shift
done

function warn() {
  printf 'warning: %s\n' "$*" >&2
}

function die() {
  printf 'error: %s\n' "$*" >&2
  exit 1
}

function prompt_yes() {
  local prompt="$1"
  if $FORCE || $NON_INTERACTIVE || [ ! -t 0 ]; then
    return 0
  fi
  printf "%s" "$prompt"
  read -r response
  case "$response" in
    [yY]|[yY][eE][sS]) return 0 ;;
    *) return 1 ;;
  esac
}

function detect_shell_rc() {
  local shell_rc
  case "${SHELL:-}" in
    */zsh)
      shell_rc="${ZDOTDIR:-$HOME}/.zshrc"
      ;;
    */bash)
      shell_rc="${HOME}/.bashrc"
      ;;
    *)
      shell_rc="${HOME}/.profile"
      ;;
  esac
  printf '%s' "$shell_rc"
}

function wrapper_snippet() {
  cat <<'EOSNIPPET'
# >>> goto init >>>
to() {

  local target_present=false
  local classify

  classify="$(command to --__classify "$@" 2>/dev/null || true)"

  if [ "$classify" = "jump" ]; then
    target_present=true
  fi

  if ! $target_present; then

    command to "$@"

    return
  fi

  # First, let the binary perform its normal jump logic (recents, expirations,
  # creation, cursor). This won't change the parent shell's cwd.
  if ! command to "$@"; then
    return $?
  fi

  # Now resolve the target path and cd in the current shell.
  local dest

  dest="$(command to --print-path "$@")" || return

  [ -z "$dest" ] && return

  if [ ! -d "$dest" ]; then
    printf 'error: resolved path "%s" does not exist\n' "$dest" >&2
    return 1
  fi

  cd "$dest"
}
# <<< goto init <<<
EOSNIPPET
}

function install_wrapper_file() {

  local dir
  dir="$(dirname "$WRAPPER_PATH")"
  mkdir -p "$dir"

  local action="installed"
  if [ -f "$WRAPPER_PATH" ]; then
    if wrapper_snippet | cmp -s - "$WRAPPER_PATH"; then
      action="unchanged"
    else
      action="updated"
    fi
  fi

  if [ "$action" != "unchanged" ]; then
    wrapper_snippet >"$WRAPPER_PATH"
  fi

  printf 'Wrapper script at %s (%s)\n' "$WRAPPER_PATH" "$action"
}

function install_completion_file() {

  mkdir -p "$COMPLETION_DIR"

  local action="installed"
  if [ -f "$COMPLETION_FILE" ]; then
    if to --generate-completions zsh | cmp -s - "$COMPLETION_FILE"; then
      action="unchanged"
    else
      action="updated"
    fi
  fi

  if [ "$action" != "unchanged" ]; then
    to --generate-completions zsh >"$COMPLETION_FILE"
  fi

  printf 'Zsh completion at %s (%s)\n' "$COMPLETION_FILE" "$action"
}

function maybe_add_wrapper() {
    local rc_file
    rc_file="$(detect_shell_rc)"

    local rc_target
    if [ -L "$rc_file" ]; then
        rc_target="$(python3 - <<'PY'
import os, sys
print(os.path.realpath(sys.argv[1]))
PY
"$rc_file")"
    else
        rc_target="$rc_file"
    fi

    local startMarker="# >>> goto init >>>"
    local endMarker="# <<< goto init <<<"
    local snippet
    snippet=$(cat <<'EOSNIPPET'
# >>> goto init >>>
GOTO_FUNC_PATH="${XDG_CONFIG_HOME:-$HOME/.config}/zsh/plugins/goto/goto.zsh"
GOTO_COMP_DIR="${XDG_CONFIG_HOME:-$HOME/.config}/zsh/completions"
if [ -d "$GOTO_COMP_DIR" ]; then
  case " ${fpath[*]} " in
    *" $GOTO_COMP_DIR "*) ;;
    *) fpath=("$GOTO_COMP_DIR" $fpath) ;;
  esac
fi
if [ -f "$GOTO_FUNC_PATH" ]; then
  if ! . "$GOTO_FUNC_PATH" 2>&1; then
    echo "Error: Failed to source \"$(basename "$GOTO_FUNC_PATH")\"" >&2
  fi
else
  echo "Error: \"$(basename "$GOTO_FUNC_PATH")\" not found at:" >&2
  echo "  $GOTO_FUNC_PATH" >&2
fi
if (( ! $+_comps[to] )); then
  autoload -Uz compinit
  compinit -i
fi
unset GOTO_FUNC_PATH
unset GOTO_COMP_DIR
# <<< goto init <<<
EOSNIPPET
)
    local snippet_no_markers
    snippet_no_markers="$(printf '%s\n' "$snippet" | sed '1d;$d')"
    local snippet_b64
    snippet_b64="$(printf '%s' "$snippet" | base64)"
    local snippet_no_markers_b64
    snippet_no_markers_b64="$(printf '%s' "$snippet_no_markers" | base64)"
    local marker_present=false
    local path_present=false

    # Gather candidate shell init files to scan
    local -a rc_candidates
    rc_candidates+=("$rc_file")

    case "${SHELL:-}" in
        */zsh)
            rc_candidates+=("${ZDOTDIR:-$HOME}/.zshenv")
            ;;
        */bash)
            rc_candidates+=("$HOME/.bash_profile")
            ;;
    esac

    for cand in "${rc_candidates[@]}"; do
        [ -f "$cand" ] || continue
        if grep -q "$startMarker" "$cand"; then
            marker_present=true
            break
        fi
    done

    if ! $marker_present; then
        # Detect the entire snippet (with markers) already present.
        for cand in "${rc_candidates[@]}"; do
            [ -f "$cand" ] || continue
            if SNIPPET_B64="$snippet_b64" python3 - "$cand" <<'PY'
import base64, os, pathlib, sys
path = pathlib.Path(sys.argv[1])
needle = base64.b64decode(os.environ["SNIPPET_B64"]).decode()
sys.exit(0 if needle in path.read_text() else 1)
PY
            then
                path_present=true
                break
            fi
        done
    fi

    if ! $marker_present && ! $path_present; then
        # Detect the snippet body when the comment markers were removed.
        for cand in "${rc_candidates[@]}"; do
            [ -f "$cand" ] || continue
            if SNIPPET_B64="$snippet_no_markers_b64" python3 - "$cand" <<'PY'
import base64, os, pathlib, sys
path = pathlib.Path(sys.argv[1])
needle = base64.b64decode(os.environ["SNIPPET_B64"]).decode()
sys.exit(0 if needle in path.read_text() else 1)
PY
            then
                path_present=true
                break
            fi
        done
    fi

    if $marker_present || $path_present; then
        printf 'Shell wrapper already present in %s; skipping add.\n' "$rc_file"
        return
    fi

    if $FORCE || prompt_yes "Add shell wrapper to ${rc_file}? [y/N]: "; then
        mkdir -p "$(dirname "$rc_target")"
        [ -f "$rc_target" ] || touch "$rc_target"

        local escapedSnippet
        escapedSnippet="$(printf '%s\n' "$snippet" | sed -e 's/[\\/&]/\\&/g')"
        local tempFile
        tempFile="$(mktemp)"
        local blockAction="added"

        if $marker_present; then
            SNIPPET="$snippet" python3 - "$rc_target" "$startMarker" "$endMarker" >"$tempFile" <<'PY'
import sys, re, pathlib, os
path, start, end = sys.argv[1:]
snippet = os.environ["SNIPPET"]
text = pathlib.Path(path).read_text()
pattern = re.compile(re.escape(start) + r".*?" + re.escape(end), re.S)
new = pattern.sub(snippet, text)
sys.stdout.write(new)
PY
            blockAction="updated"
        elif grep -q 'command to --print-path' "$rc_target"; then
            # legacy block; replace whole function with new snippet
            SNIPPET="$snippet" python3 - "$rc_target" "$startMarker" "$endMarker" >"$tempFile" <<'PY'
import sys, pathlib, os
path = sys.argv[1]
snippet = os.environ["SNIPPET"]
text = pathlib.Path(path).read_text()
text = text + ("\n" if not text.endswith("\n") else "")
text += snippet + "\n"
sys.stdout.write(text)
PY
            blockAction="updated"
        elif $path_present; then
            # Already sourcing the wrapper without our markers; leave as-is.
            printf 'Shell wrapper already present in %s (detected existing source); leaving untouched.\n' "$rc_file"
            rm "$tempFile"
            return
        else
            cat "$rc_target" > "$tempFile"
            printf '\n%s\n' "$snippet" >> "$tempFile"
        fi

        if cmp -s "$tempFile" "$rc_target"; then
            blockAction="unchanged"
            rm "$tempFile"
        else
            cat "$tempFile" >"$rc_target"
            rm "$tempFile"
        fi

        printf 'Shell wrapper in %s (%s). Reload your shell to use it.\n' "$rc_file" "$blockAction"
    else
        printf 'Skipping shell wrapper. You can add it manually to %s:\n' "$rc_file"
        wrapper_snippet
    fi
}

LEGACY_OUT="$(zsh -lc 'whence -w to' 2>/dev/null || true)"
if printf '%s' "$LEGACY_OUT" | grep -q "function"; then
  warn "found existing Zsh function 'to' (likely from to-zsh) in your shell environment."
  warn "If you want to remove it first, run the to-zsh uninstall script (e.g., ~/.config/zsh/plugins/to-zsh/uninstall) or remove the function from your shell config."
  if ! $FORCE && ! prompt_yes "Proceed anyway? [y/N]: "; then
    die "aborting to avoid conflict with existing 'to'. Run with --force to override."
  fi
fi

EXISTING_BIN="$(command -v to 2>/dev/null || true)"
if [ -n "$EXISTING_BIN" ]; then
  if [ "$EXISTING_BIN" = "$TARGET_PATH" ]; then
    printf "Existing 'to' already resolves to %s; continuing.\n" "$TARGET_PATH"
  else
    warn "'to' command already on PATH at $EXISTING_BIN (expected $TARGET_PATH)"
    if ! $FORCE && ! prompt_yes "Proceed and overwrite via cargo install? [y/N]: "; then
      die "aborting to avoid clobbering existing 'to'."
    fi
  fi
fi

CONFIG_ROOT="${HOME}/.goto"
CONFIG_FILES=(
  "${TO_CONFIG_FILE:-$CONFIG_ROOT/to_dirs}"
  "${TO_CONFIG_META_FILE:-$CONFIG_ROOT/to_dirs_meta}"
  "${TO_USER_CONFIG_FILE:-$CONFIG_ROOT/to_zsh_config}"
  "${TO_RECENT_FILE:-$CONFIG_ROOT/to_dirs_recent}"
)

CONFIG_FOUND=false
CONFIG_COUNT=0
for f in "${CONFIG_FILES[@]}"; do
  if [ -e "$f" ]; then
    CONFIG_FOUND=true
    CONFIG_COUNT=$((CONFIG_COUNT + 1))
  fi
done

if $CONFIG_FOUND; then
  warn "found ${CONFIG_COUNT} existing config file(s) under ${CONFIG_ROOT}; proceeding will reuse them."
fi

install_wrapper_file

EXISTING_COMPLETION="$(zsh -lc 'for d in $fpath; if [ -f $d/_to ]; then print $d/_to; break; fi; done' 2>/dev/null || true)"
if [ -n "$EXISTING_COMPLETION" ] && [ "$EXISTING_COMPLETION" != "$COMPLETION_FILE" ]; then
  warn "existing zsh completion for 'to' found at $EXISTING_COMPLETION"
  if ! $FORCE && ! prompt_yes "Use existing completion and skip installing ours? [y/N]: "; then
    install_completion_file
  else
    printf 'Keeping existing completion at %s\n' "$EXISTING_COMPLETION"
  fi
else
  install_completion_file
fi

printf 'Installing %s from %s\n' "$PROJECT_NAME" "$SCRIPT_DIR"
printf 'Target binary: %s\n' "$TARGET_PATH"

if ((${#CARGO_ARGS[@]})); then
  cargo install --path "$SCRIPT_DIR" --locked --force "${CARGO_ARGS[@]}"
else
  cargo install --path "$SCRIPT_DIR" --locked --force
fi

RESOLVED_BIN="$(command -v "$BIN_NAME" 2>/dev/null || true)"

if [ -x "$RESOLVED_BIN" ]; then
  if [ "$RESOLVED_BIN" = "$TARGET_PATH" ]; then
    printf '%s installation complete at %s\n' "$PROJECT_NAME" "$RESOLVED_BIN"
  else
    printf '%s installation complete, but PATH resolves to %s (expected %s)\n' "$PROJECT_NAME" "$RESOLVED_BIN" "$TARGET_PATH"
  fi
  maybe_add_wrapper
else
  warn "installed $PROJECT_NAME but could not resolve binary on PATH; ensure \$CARGO_HOME/bin is on PATH."
fi
