#!/usr/bin/env bash
set -euo pipefail

if ! command -v cargo >/dev/null 2>&1; then
  echo "error: cargo is required but was not found in PATH." >&2
  echo "Install Rust via https://rustup.rs/ and ensure cargo is available." >&2
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

BIN_NAME="to"
PROJECT_NAME="to"
CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"

usage() {
  cat <<'EOUSAGE'
Usage: ./install [FLAGS] [cargo install flags]

Flags:
  -y, --yes, --force     bypass conflict prompts and proceed
  -q, --quiet            suppress prompts (implies --yes)
  -h, --help             display this help message

All other arguments are forwarded to "cargo install".
EOUSAGE
}

FORCE=false
NON_INTERACTIVE=false
CARGO_ARGS=()

while (($#)); do
  case "$1" in
    -q|--quiet)
      NON_INTERACTIVE=true
      FORCE=true
      ;;
    -y|--yes|--force)
      FORCE=true
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      CARGO_ARGS+=("$1")
      ;;
  esac
  shift
done

function warn() {
  printf 'warning: %s\n' "$*" >&2
}

function die() {
  printf 'error: %s\n' "$*" >&2
  exit 1
}

function prompt_yes() {
  local prompt="$1"
  if $FORCE || $NON_INTERACTIVE || [ ! -t 0 ]; then
    return 0
  fi
  printf "%s" "$prompt"
  read -r response
  case "$response" in
    [yY]|[yY][eE][sS]) return 0 ;;
    *) return 1 ;;
  esac
}

function detect_shell_rc() {
  local shell_rc
  case "${SHELL:-}" in
    */zsh)
      shell_rc="${ZDOTDIR:-$HOME}/.zshrc"
      ;;
    */bash)
      shell_rc="${HOME}/.bashrc"
      ;;
    *)
      shell_rc="${HOME}/.profile"
      ;;
  esac
  printf '%s' "$shell_rc"
}

function wrapper_snippet() {
  cat <<'EOSNIPPET'
# >>> goto init >>>
to() {
  local dest
  dest="$(command to --print-path "$@")" || return
  [ -z "$dest" ] && return
  mkdir -p "$dest"
  cd "$dest"
}
# <<< goto init <<<
EOSNIPPET
}

function maybe_add_wrapper() {
  local rc_file
  rc_file="$(detect_shell_rc)"

  local startMarker="# >>> goto init >>>"
  local endMarker="# <<< goto init <<<"

  if $FORCE || prompt_yes "Add shell wrapper to ${rc_file}? [y/N]: "; then
    mkdir -p "$(dirname "$rc_file")"
    [ -f "$rc_file" ] || touch "$rc_file"

    local snippet
    snippet="$(wrapper_snippet)"
    local escapedSnippet
    escapedSnippet="$(printf '%s\n' "$snippet" | sed -e 's/[\\/&]/\\&/g')"
    local tempFile
    tempFile="$(mktemp)"

    if grep -q "$startMarker" "$rc_file"; then
      perl -0777 -pe "s|$startMarker.*?$endMarker|$escapedSnippet|s" "$rc_file" > "$tempFile"
    else
      cat "$rc_file" > "$tempFile"
      printf '\n%s\n' "$snippet" >> "$tempFile"
    fi

    mv "$tempFile" "$rc_file"
    printf 'Added shell wrapper block (%s â€¦ %s) to %s. Reload your shell to use it.\n' "$startMarker" "$endMarker" "$rc_file"
  else
    printf 'Skipping shell wrapper. You can add it manually to %s:\n' "$rc_file"
    wrapper_snippet
  fi
}

LEGACY_OUT="$(zsh -lc 'whence -w to' 2>/dev/null || true)"
if printf '%s' "$LEGACY_OUT" | grep -q "function"; then
  warn "found existing Zsh function 'to' (likely from to-zsh) in your shell environment."
  warn "If you want to remove it first, run the to-zsh uninstall script (e.g., ~/.config/zsh/plugins/to-zsh/uninstall) or remove the function from your shell config."
  if ! $FORCE && ! prompt_yes "Proceed anyway? [y/N]: "; then
    die "aborting to avoid conflict with existing 'to'. Run with --force to override."
  fi
fi

EXISTING_BIN="$(command -v to 2>/dev/null || true)"
if [ -n "$EXISTING_BIN" ] && [ "$EXISTING_BIN" != "$CARGO_HOME/bin/to" ]; then
  warn "'to' command already on PATH at $EXISTING_BIN"
  if ! $FORCE && ! prompt_yes "Proceed and overwrite via cargo install? [y/N]: "; then
    die "aborting to avoid clobbering existing 'to'."
  fi
fi

CONFIG_ROOT="${HOME}/.goto"
CONFIG_FILES=(
  "${TO_CONFIG_FILE:-$CONFIG_ROOT/to_dirs}"
  "${TO_CONFIG_META_FILE:-$CONFIG_ROOT/to_dirs_meta}"
  "${TO_USER_CONFIG_FILE:-$CONFIG_ROOT/to_zsh_config}"
  "${TO_RECENT_FILE:-$CONFIG_ROOT/to_dirs_recent}"
)

CONFIG_FOUND=false
for f in "${CONFIG_FILES[@]}"; do
  if [ -e "$f" ]; then
    CONFIG_FOUND=true
  fi
done

if $CONFIG_FOUND; then
  warn "existing to config files detected in ${CONFIG_ROOT}; proceeding will reuse them."
fi

printf 'Installing %s from %s\n' "$PROJECT_NAME" "$SCRIPT_DIR"

if ((${#CARGO_ARGS[@]})); then
  cargo install --path "$SCRIPT_DIR" --locked --force "${CARGO_ARGS[@]}"
else
  cargo install --path "$SCRIPT_DIR" --locked --force
fi

TARGET_PATH="$(command -v "$BIN_NAME" 2>/dev/null || true)"

if [ -x "$TARGET_PATH" ]; then
  printf '%s installation complete at %s\n' "$PROJECT_NAME" "$TARGET_PATH"
  maybe_add_wrapper
else
  warn "installed $PROJECT_NAME but could not resolve binary on PATH; ensure \$CARGO_HOME/bin is on PATH."
fi

}
