#!/usr/bin/env bash
set -euo pipefail

if ! command -v cargo >/dev/null 2>&1; then
  echo "error: cargo is required but was not found in PATH." >&2
  echo "Install Rust via https://rustup.rs/ and ensure cargo is available." >&2
  exit 1
fi

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"

BIN_NAME="to"
PROJECT_NAME="to"
CARGO_HOME="${CARGO_HOME:-$HOME/.cargo}"
TARGET_PATH="${CARGO_HOME}/bin/${BIN_NAME}"

usage() {
  cat <<'EOUSAGE'
Usage: ./install [FLAGS] [cargo install flags]

Flags:
  -y, --yes, --force     bypass conflict prompts and proceed
  -q, --quiet            suppress prompts (implies --yes)
  -h, --help             display this help message

All other arguments are forwarded to "cargo install".
EOUSAGE
}

FORCE=false
NON_INTERACTIVE=false
CARGO_ARGS=()

while (($#)); do
  case "$1" in
    -q|--quiet)
      NON_INTERACTIVE=true
      FORCE=true
      ;;
    -y|--yes|--force)
      FORCE=true
      ;;
    -h|--help)
      usage
      exit 0
      ;;
    *)
      CARGO_ARGS+=("$1")
      ;;
  esac
  shift
done

function warn() {
  printf 'warning: %s\n' "$*" >&2
}

function die() {
  printf 'error: %s\n' "$*" >&2
  exit 1
}

function prompt_yes() {
  local prompt="$1"
  if $FORCE || $NON_INTERACTIVE || [ ! -t 0 ]; then
    return 0
  fi
  printf "%s" "$prompt"
  read -r response
  case "$response" in
    [yY]|[yY][eE][sS]) return 0 ;;
    *) return 1 ;;
  esac
}

function detect_shell_rc() {
  local shell_rc
  case "${SHELL:-}" in
    */zsh)
      shell_rc="${ZDOTDIR:-$HOME}/.zshrc"
      ;;
    */bash)
      shell_rc="${HOME}/.bashrc"
      ;;
    *)
      shell_rc="${HOME}/.profile"
      ;;
  esac
  printf '%s' "$shell_rc"
}

function wrapper_snippet() {
  cat <<'EOSNIPPET'
# >>> goto init >>>
to() {

  case "$1" in
    ""|\
    -h|--help|\
    -V|--version|\
    -l|--list|\
    -a|--add|\
    --add-bulk|\
    --copy|\
    -r|--rm|\
    -s|--sort|\
    --print-path|\
    -p|\
    --generate-completions|\
    --expire|\
    --no-color|\
    --__complete-mode|\
    --__complete-input)

      command to "$@"

      return
      ;;

    --)

      shift
      ;;
  esac

  # First, let the binary perform its normal jump logic (recents, expirations,
  # creation, cursor). This won't change the parent shell's cwd.
  if ! command to "$@"; then
    return $?
  fi

  # Now resolve the target path and cd in the current shell.
  local dest

  dest="$(command to --print-path "$@")" || return

  [ -z "$dest" ] && return

  if [ ! -d "$dest" ]; then
    printf 'error: resolved path "%s" does not exist\n' "$dest" >&2
    return 1
  fi

  cd "$dest"
}
# <<< goto init <<<
EOSNIPPET
}

function maybe_add_wrapper() {
    local rc_file
    rc_file="$(detect_shell_rc)"

    local startMarker="# >>> goto init >>>"
    local endMarker="# <<< goto init <<<"

    if $FORCE || prompt_yes "Add shell wrapper to ${rc_file}? [y/N]: "; then
        mkdir -p "$(dirname "$rc_file")"
        [ -f "$rc_file" ] || touch "$rc_file"

        local snippet
        snippet="$(wrapper_snippet)"
        local escapedSnippet
        escapedSnippet="$(printf '%s\n' "$snippet" | sed -e 's/[\\/&]/\\&/g')"
        local tempFile
        tempFile="$(mktemp)"
        local blockAction="added"

        if grep -q "$startMarker" "$rc_file"; then
            perl -0777 -pe "s|$startMarker.*?$endMarker|$escapedSnippet|s" "$rc_file" > "$tempFile"
            blockAction="updated"
        elif grep -q 'command to --print-path' "$rc_file"; then
            perl -0777 -pe "s|to\(\)\s*\{[^\}]*command to --print-path.*?\}\s*|$escapedSnippet|s" "$rc_file" > "$tempFile"
            blockAction="updated"
        else
            cat "$rc_file" > "$tempFile"
            printf '\n%s\n' "$snippet" >> "$tempFile"
        fi

        if cmp -s "$tempFile" "$rc_file"; then
            blockAction="unchanged"
            rm "$tempFile"
        else
            mv "$tempFile" "$rc_file"
        fi

        printf 'Shell wrapper in %s (%s). Reload your shell to use it.\n' "$rc_file" "$blockAction"
    else
        printf 'Skipping shell wrapper. You can add it manually to %s:\n' "$rc_file"
        wrapper_snippet
    fi
}

LEGACY_OUT="$(zsh -lc 'whence -w to' 2>/dev/null || true)"
if printf '%s' "$LEGACY_OUT" | grep -q "function"; then
  warn "found existing Zsh function 'to' (likely from to-zsh) in your shell environment."
  warn "If you want to remove it first, run the to-zsh uninstall script (e.g., ~/.config/zsh/plugins/to-zsh/uninstall) or remove the function from your shell config."
  if ! $FORCE && ! prompt_yes "Proceed anyway? [y/N]: "; then
    die "aborting to avoid conflict with existing 'to'. Run with --force to override."
  fi
fi

EXISTING_BIN="$(command -v to 2>/dev/null || true)"
if [ -n "$EXISTING_BIN" ]; then
  if [ "$EXISTING_BIN" = "$TARGET_PATH" ]; then
    printf "Existing 'to' already resolves to %s; continuing.\n" "$TARGET_PATH"
  else
    warn "'to' command already on PATH at $EXISTING_BIN (expected $TARGET_PATH)"
    if ! $FORCE && ! prompt_yes "Proceed and overwrite via cargo install? [y/N]: "; then
      die "aborting to avoid clobbering existing 'to'."
    fi
  fi
fi

CONFIG_ROOT="${HOME}/.goto"
CONFIG_FILES=(
  "${TO_CONFIG_FILE:-$CONFIG_ROOT/to_dirs}"
  "${TO_CONFIG_META_FILE:-$CONFIG_ROOT/to_dirs_meta}"
  "${TO_USER_CONFIG_FILE:-$CONFIG_ROOT/to_zsh_config}"
  "${TO_RECENT_FILE:-$CONFIG_ROOT/to_dirs_recent}"
)

CONFIG_FOUND=false
CONFIG_COUNT=0
for f in "${CONFIG_FILES[@]}"; do
  if [ -e "$f" ]; then
    CONFIG_FOUND=true
    CONFIG_COUNT=$((CONFIG_COUNT + 1))
  fi
done

if $CONFIG_FOUND; then
  warn "found ${CONFIG_COUNT} existing config file(s) under ${CONFIG_ROOT}; proceeding will reuse them."
fi

printf 'Installing %s from %s\n' "$PROJECT_NAME" "$SCRIPT_DIR"
printf 'Target binary: %s\n' "$TARGET_PATH"

if ((${#CARGO_ARGS[@]})); then
  cargo install --path "$SCRIPT_DIR" --locked --force "${CARGO_ARGS[@]}"
else
  cargo install --path "$SCRIPT_DIR" --locked --force
fi

RESOLVED_BIN="$(command -v "$BIN_NAME" 2>/dev/null || true)"

if [ -x "$RESOLVED_BIN" ]; then
  if [ "$RESOLVED_BIN" = "$TARGET_PATH" ]; then
    printf '%s installation complete at %s\n' "$PROJECT_NAME" "$RESOLVED_BIN"
  else
    printf '%s installation complete, but PATH resolves to %s (expected %s)\n' "$PROJECT_NAME" "$RESOLVED_BIN" "$TARGET_PATH"
  fi
  maybe_add_wrapper
else
  warn "installed $PROJECT_NAME but could not resolve binary on PATH; ensure \$CARGO_HOME/bin is on PATH."
fi
